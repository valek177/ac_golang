# Easy version

Есть процессор, который выполняет долгие и ресурсоёмкие операции. Нужно сделать для него **обёртку-шедулер**, которая:
- принимает внешние запросы,
- запускает их обработку через процессор,
- ограничивает число одновременных обработок (не выше заданного порога).

Поверх шедулера будет веб-сервер (например, gRPC), генерируемый автоматически по его публичным методам.

Ограничения:
1. Сигнатуры методов processor, storage менять нельзя.
2. Среда выполнения — cloud-native: шедулер работает внутри Kubernetes, нужно учитывать особенности облака (масштабирование, перезапуски контейнеров и т.д.).
3. Для хранения данных используется быстрое персистентное хранилище (по сути, БД), которое поддерживает Create/Update, поиск по primary key и выборку по критериям.

Нужно:
- спроектировать интерфейс шедулера
- реализовать его методы так, чтобы обрабатывать внешние запросы без превышения лимита одновременных операций
- использовать хранилище для работы с данными
- для шедулера нужно иметь возможность прекратить добавлять задачи на исполнение и возвращать ошибку, а оставшиеся задачи в очереди должны быть исполнены (метод Close)

# Hard version

Есть процессор, который выполняет долгие и ресурсоёмкие операции. Нужно сделать для него **обёртку-шедулер**, которая:
- принимает внешние запросы,
- запускает их обработку через процессор,
- ограничивает число одновременных обработок (не выше заданного порога).

Поверх шедулера будет веб-сервер (например, gRPC), генерируемый автоматически по его публичным методам.

Ограничения:
1. Сигнатуры методов processor, storage менять нельзя.
2. Среда выполнения — cloud-native: шедулер работает внутри Kubernetes, нужно учитывать особенности облака (масштабирование, перезапуски контейнеров и т.д.).
3. Для хранения данных используется быстрое персистентное хранилище (по сути, БД), которое поддерживает Create/Update, поиск по primary key и выборку по критериям. В базе данных храним хэши записей. При получении нового запроса сначала ищем существующую запись по хэшу, если она есть, возвращаем ее uuid.

Нужно:
- спроектировать интерфейс шедулера
- реализовать его методы так, чтобы обрабатывать внешние запросы без превышения лимита одновременных операций
- использовать хранилище для работы с данными
- для шедулера нужно иметь возможность прекратить добавлять задачи на исполнение и возвращать ошибку, а оставшиеся задачи в очереди должны быть исполнены (метод Close)

# Начальный шаблон

```
package scheduler

type processor interface {
    Process([]byte) ([]byte, error)
}

type FindOperator struct {
    key, operator, value string
}

type UUID string

type storage[T any] interface {
    Store(T) UUID 
    Get(UUID) T 
    Find([]FindOperator) []T // select 
}

type Task struct {
    //TODO
}

const (
	StatusProcessing = "processing"
	StatusQueued     = "queued"
	StatusDone       = "done"
	StatusError      = "error"
)

type Scheduler struct {
    //TODO
}

//TODO scheduler methods
func NewScheduler(st storage[Task], proc processor, numWorkers, queueSize int) (*Scheduler, error) {
    //TODO
}

func (s *Scheduler) worker() {
    //TODO
}

func (s *Scheduler) AddTask(request []byte) (UUID, error) {
    //TODO
}

func (s *Scheduler) GetTask(uuid UUID) Task {
    //TODO
}

func (s *Scheduler) Close() {
    //TODO
}
```
